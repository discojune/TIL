# 99í´ëŸ½ ì½”í…Œ ìŠ¤í„°ë”” 14ì¼ì°¨ TIL : DFS/BFS(ê¹Šì´/ë„ˆë¹„ ìš°ì„  íƒìƒ‰)

## All Paths From Source to Target
ë¦¬íŠ¸ì½”ë“œ ë¬¸ì œ ë§í¬:
- https://leetcode.com/problems/all-paths-from-source-to-target/description/


## í’€ì´ 1. ê¹Šì´ ìš°ì„  íƒìƒ‰

### ğŸ¤” ì‹œí–‰ ì°©ì˜¤
ë§ˆì§€ë§‰ ë…¸ë“œê¹Œì§€ ë„ì°©í•˜ëŠ” ëª¨ë“  ê²½ë¡œë¥¼ êµ¬í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.

ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ í•  ë•Œ ê° ê²½ë¡œë§ˆë‹¤ ë”°ë¡œ pathë¥¼ êµ¬í•˜ê¸° ìœ„í•´ ë¶ˆë³€ê°ì²´ì¸ ë¬¸ìì—´ í˜•ì‹ìœ¼ë¡œ ê²½ë¡œê°’ì„ ì €ì¥í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ëŒ€ë¶€ë¶„ì˜ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. (ì‹œê°„ë³µì¡ë„ì—ì„œ ìµœí•˜ìœ„ì— ì†í•˜ëŠ” í’€ì´ì´ë¯€ë¡œ ê°œì„ ì´ í•„ìš”í•˜ë‹¤.)

í•˜ì§€ë§Œ ëª‡ëª‡ ë¬¸ì œì—ì„œ ì‹¤íŒ¨ë¥¼ í•˜ì˜€ë‹¤.

### ğŸ’¡ ìƒˆë¡­ê²Œ ì•Œê²Œ ëœ ê²ƒ
ì´ë²ˆì—ë„ ë¬¸ì œë¥¼ ì œëŒ€ë¡œ ì´í•´í•˜ì§€ ëª»í•´ ì‹¤íŒ¨í•œ ë¬¸ì œê°€ ìˆì—ˆëŠ”ë° (n - 1) ë…¸ë“œë¡œ ëë‚˜ëŠ” ê²½ë¡œë§Œ ì°¾ì•„ì•¼ í•œë‹¤ëŠ” ê²ƒì´ì—ˆë‹¤.
ì´ë¥¼ ìœ„í•´ ë§ˆì§€ë§‰ ë…¸ë“œê°€ ```len(graph) - 1``` ì¸ ê²½ìš°ë¥¼ ì¶”ê°€í•´ì„œ ë¬¸ì œë¥¼ í•´ê²° í•  ìˆ˜ ìˆì—ˆë‹¤.

### ğŸ˜… ê°œì„ ì´ í•„ìš”í•œ í’€ì´ ì½”ë“œ
```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        from collections import deque

        root = 0
        queue = deque([(graph[root], "0")])

        paths = []
        while queue:
            curr_node, path = queue.popleft()

            for next_idx in curr_node:
                new_path = path + ',' + str(next_idx)

                next_node = graph[next_idx]
                
                if not next_node and int(new_path.split(',')[-1]) == len(graph)-1:
                    paths.append([int(s) for s in new_path.split(',')])
                    continue

                if int(new_path.split(',')[-1]) == len(graph)-1:
                    paths.append([int(s) for s in new_path.split(',')])

                queue.append([next_node, new_path])
        

        return paths

```

### ğŸƒ studying with...
#99í´ëŸ½ #ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ #ê°œë°œì ì·¨ì—… #í•­í•´99 #TIL
![til_thumbnail](./img/thmb_python.png)