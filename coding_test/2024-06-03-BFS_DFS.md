# 99ÌÅ¥ÎüΩ ÏΩîÌÖå Ïä§ÌÑ∞Îîî 15ÏùºÏ∞® TIL : DFS/BFS(ÍπäÏù¥/ÎÑàÎπÑ Ïö∞ÏÑ† ÌÉêÏÉâ)

## Reverse Odd Levels of Binary Tree
Î¶¨Ìä∏ÏΩîÎìú Î¨∏Ï†ú ÎßÅÌÅ¨:
- https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/


## ÌíÄÏù¥ 1. ÎÑàÎπÑ Ïö∞ÏÑ† ÌÉêÏÉâ

### ü§î ÏãúÌñâ Ï∞©Ïò§
ÏôÑÏ†Ñ Ïù¥ÏßÑ Ìä∏Î¶¨Ïùò ÌôÄÏàò Î†àÎ≤®Ïùò ÎÖ∏ÎìúÏùò Í∞íÏùÑ Ïó≠ÏàúÏúºÎ°ú Î∞îÍæ∏Îäî Î¨∏Ï†úÏù¥Í∏∞ ÎïåÎ¨∏Ïóê ÎÑàÎπÑ Ïö∞ÏÑ† ÌÉêÏÉâÏùÑ ÏÇ¨Ïö©ÌñàÎã§.

Ïó≠ÏàúÏúºÎ°ú ÎÖ∏ÎìúÎ•º Î∞∞ÏπòÌïòÍ∏∞ ÏúÑÌï¥ Í∞Å ÎÖ∏ÎìúÎ•º Ïñë ÎÅùÏóêÏÑúÎ∂ÄÌÑ∞ Ï§ëÏïôÏúºÎ°ú ÏßùÏùÑ ÏßÄÏñ¥ÏÑú ÏûêÎ¶¨Î•º Î∞îÍæ∏Îäî Î∞©ÏãùÏúºÎ°ú Î¨∏Ï†úÎ•º ÌíÄÏóàÎã§.

Ïù¥Îïå Í∏∞Ï°¥Ïùò BFS Î∞©ÏãùÏóêÏÑú popÏùÑ Í∞ÄÏ†∏Ïò® ÎÖ∏ÎìúÏùò ÏûêÏãù ÎÖ∏ÎìúÎ•º ÏàúÏÑúÎåÄÎ°ú Ï†ÄÏû•ÌïòÎ©¥ Îã§Ïùå Î†àÎ≤®Ïùò Í∞íÏù¥ Îí§Ï£ΩÎ∞ïÏ£ΩÏù¥ ÎêòÎäî Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÎã§.

Ïù¥Î•º Î∞©ÏßÄÌïòÍ∏∞ ÏúÑÌï¥ Îëê ÏßùÏùò ÏûêÏãù ÎÖ∏ÎìúÎ•º Ï†ÄÏû•Ìï† Îëê Î¶¨Ïä§Ìä∏Î•º ÏÉùÏÑ±ÌïòÍ≥†, ÏõêÎ≥∏ ÏôÑÏ†Ñ Ïù¥ÏßÑ Ìä∏Î¶¨Ïùò ÏàúÏÑúÏóê ÎßûÍ≤å Î¶¨Ïä§Ìä∏Ïóê Ï†ÄÏû•ÎêòÎèÑÎ°ù ÌïòÏó¨ Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌñàÎã§.


### üéâ ÌíÄÏù¥ ÏΩîÎìú
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        from collections import deque

        level = 0
        queue = deque([root])

        while queue:
   
            if level % 2 != 0:

                queue_left = []
                queue_right = []

                for _ in range(int(len(queue) / 2)):
                    node_1 = queue.popleft()
                    node_2 = queue.pop()

                    node_1_value = node_1.val
                    node_2_value = node_2.val

                    node_1.val = node_2_value
                    node_2.val = node_1_value

                    if node_1.left:
                        queue_left.append(node_1.left)
                        queue_left.append(node_1.right)
                    
                    if node_2.left:
                        queue_right.insert(0, node_2.left)
                        queue_right.insert(1, node_2.right)

                merge = queue_right + queue_left         
                queue = deque(merge)

            else:
                for _ in range(len(queue)):
                    node = queue.popleft()

                    if node.left:
                        queue.append(node.left)
                        queue.append(node.right)
                        
            level += 1     

        return root        

```

### üèÉ studying with...
#99ÌÅ¥ÎüΩ #ÏΩîÎî©ÌÖåÏä§Ìä∏ Ï§ÄÎπÑ #Í∞úÎ∞úÏûê Ï∑®ÏóÖ #Ìï≠Ìï¥99 #TIL
![til_thumbnail](./img/thmb_python.png)